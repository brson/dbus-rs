//! tokio/tokio-core/mio integration
//!
//! This is a basic proof of concept for how to integrate dbus into
//! tokio. It is derived from tokio-curl:
//!
//! https://github.com/tokio-rs/tokio-curl/blob/master/src/unix.rs
//!
//! The basic problem to overcome here is to communicate the dbus
//! 'watch' set of fds to tokio-core, while communicating readiness
//! back to dbus and pumping the dbus callbacks.
//!
//! Unfortunately, cases that need to communicate fds to tokio need to
//! interop directly with the concrete event loop, in this case
//! tokio-core mio. Thus, this is not as abstracted as one might like,
//! though it work with the only tokio event loop implemented today.
//!
//! The basic strategy here is to create a 'secret' task, called
//! DBusDriver that is responsible for communicating the dbus
//! watch list to tokio-core via PollEvented, pump the dbus event
//! handlers with dbus_connection_dispatch, interpret the work items
//! generated by the dbus callbacks, and finally dispatch IPC
//! responses to fulfill user-facing futures.

extern crate futures;
extern crate tokio_core;
extern crate mio;

use ffi;
use libc;
use watch::Watch;
use super::WatchEvent;
use std::collections::HashMap;
use std::marker::PhantomData;
use std::io;
use std::cell::RefCell;
use std::rc::Rc;
use std::os::unix::io::RawFd;
use self::futures::{Future, Poll, Async, Stream};
use self::futures::stream::Fuse;
use self::futures::task::{self, Task};
use self::futures::unsync::oneshot::{self, Sender, Receiver};
use self::futures::unsync::mpsc::{unbounded, UnboundedSender, UnboundedReceiver};
use super::{BusName, Error, Interface, Member, Message, Path, Connection, ConnectionItem};
use super::arg::Get;
use self::tokio_core::reactor::{Handle, PollEvented};
use self::mio::unix::EventedFd;

pub struct TokioConnection {
    c: Rc<RefCell<Connection>>,
    driver_tx: UnboundedSender<DriverMsg>,
}

impl TokioConnection {
    pub fn new(c: Connection, handle: Handle) -> TokioConnection {
        let c = Rc::new(RefCell::new(c));
        // A channel used to communicate from TokioConnection to
        // the DBusDriver future/task.
        let (tx, rx) = unbounded();
        // Spawn a task that is going to drive the integration between
        // dbus and tokio. This will run until the tokio reactor
        // exits.
        handle.clone().spawn(DBusDriver {
            c: c.clone(),
            handle: handle,
            rx: rx.fuse(),
            call_handlers: HashMap::new(),
            watches: HashMap::new(),
        }.map_err(|e| {
            panic!("error monitoring dbus for tokio: {}", e);
        }));
        TokioConnection { c: c, driver_tx: tx }
    }

    pub fn call<'d, 'i, 'm, 'p, D, I, M, P, T>
        (&self, destination: D, path: P, iface: I, method: M) -> Result<MethodCall<T>, io::Error>
        where D: Into<BusName<'d>>,
              P: Into<Path<'p>>,
              I: Into<Interface<'i>>,
              M: Into<Member<'m>>,
              T: for <'a> Get <'a>
    {
        let msg = Message::new_method_call(destination, path, iface, method)
            .map_err(|msg| io::Error::new(io::ErrorKind::Other, msg))?;
        let (tx, rx) = oneshot::channel();
        self.driver_tx.send(DriverMsg::Call(msg, tx));
        Ok(MethodCall(rx, PhantomData))
    }
}

enum DriverMsg {
    Call(Message, Sender<Message>),
}

struct DBusDriver {
    c: Rc<RefCell<Connection>>,
    handle: Handle,
    rx: Fuse<UnboundedReceiver<DriverMsg>>,
    call_handlers: HashMap<u32, Sender<Message>>,
    watches: HashMap<RawFd, PollEvented<Watch>>,
}

impl Future for DBusDriver {
    type Item = ();
    type Error = io::Error;

    fn poll(&mut self) -> Poll<(), io::Error> {
        self.handle_messages()?;
        self.dispatch_pending_items()?;
        self.register_fds()?;
        self.do_polling()?;

        Ok(Async::NotReady)
    }
}

impl DBusDriver {
    fn handle_messages(&mut self) -> io::Result<()> {
        loop {
            let c = self.c.borrow_mut();
            let msg = self.rx.poll().expect("cannot fail");
            let msg = match msg {
                Async::Ready(Some(msg)) => msg,
                Async::Ready(None) => break,
                Async::NotReady => break,
            };

            match msg {
                DriverMsg::Call(dbus_msg, tx) => {
                    // FIXME: send shouldn't return () as error
                    let serial = c.send(dbus_msg)
                        .map_err(|()| io::Error::new(io::ErrorKind::Other, "failed to send dbus message"))?;
                    self.call_handlers.insert(serial, tx);
                }
            }
        }

        Ok(())
    }

    fn dispatch_pending_items(&mut self) -> io::Result<()> {
        let c = self.c.borrow_mut();
        loop {
            let ci = c.i.pending_items.borrow_mut().pop_front();
            if ci.is_some() {
                println!("have pending item: {:?}", ci);
            }
            match ci {
                Some(ConnectionItem::MethodCall(msg)) => {
                    // TODO respond to _incoming_ method call request?
                    panic!("got a method call, don't know what to do")
                },
                Some(ConnectionItem::MethodReturn(msg)) => {
                    let serial = msg.get_reply_serial().expect("method reply has no reply serial");

                    // FIXME: error handling
                    if let Some(tx) = self.call_handlers.remove(&serial) {
                        let send_op = tx.send(msg);
                        match send_op {
                            Ok(_) => (),
                            Err(e) => { println!("ERROR: {:?}", e); }
                        }
                    } else {
                        println!("unexpected dbus method return serial {}", serial);
                    }
                },
                Some(ConnectionItem::Signal(_)) => {
                    // TODO what do?
                    println!("got a signal, don't know what to do")
                },
                Some(ConnectionItem::WatchFd(_)) => (),
                Some(ConnectionItem::Nothing) => (),
                None => break,
            }
        }

        Ok(())
    }

    fn register_fds(&mut self) -> io::Result<()> {
        let c = self.c.borrow_mut();
        let watches = c.watch_fds();

        for watch in watches {
            let fd = watch.fd();
            use std::collections::hash_map::Entry::*;
            match self.watches.entry(fd) {
                Occupied(_) => { }
                Vacant(ve) => {
                    ve.insert(PollEvented::new(watch, &self.handle)?);
                }
            }
        }

        // FIXME: Remove watches that no longer exist

        Ok(())
    }

    fn do_polling(&mut self) -> io::Result<()> {
        let c = self.c.borrow_mut();

        for (fd, watch) in &self.watches {
            let mut read = false;
            let mut write = false;
            if watch.poll_read().is_ready() {
                read = true;
            }
            if watch.poll_write().is_ready() {
                write = true;
            }

            let mut fd = libc::pollfd {
                fd: *fd,
                events: 0,
                revents: 0,
            };
            if read {
                fd.events |= libc::POLLIN;
            }
            if write {
                fd.events |= libc::POLLOUT;
            }
            unsafe {
                libc::poll(&mut fd, 1, 0);
            }

            let mut unpark = false;
            let mut flags = 0;
            if read {
                flags |= WatchEvent::Readable as _;
                if (fd.revents & libc::POLLIN) == 0 {
                    watch.need_read();
                } else {
                    unpark = true;
                }
            }
            if write {
                flags |= WatchEvent::Writable as _;
                if (fd.revents & libc::POLLOUT) == 0 {
                    watch.need_write();
                } else {
                    unpark = true;
                }
            }

            if flags != 0 {
                c.watch_handle(fd.fd, flags);
            }

            if unpark {
                task::park().unpark();
            }
        }

        // Tell dbus to process messages
        let r = unsafe { ffi::dbus_connection_dispatch(c.conn()); };
        // TODO handle result?

        Ok(())
    }
}


pub struct MethodCall<T>(Receiver<Message>, PhantomData<T>)
    where T: for <'a> Get<'a>;

impl<T> Future for MethodCall<T>
    where T: for <'a> Get<'a>
{
    type Item = T;
    type Error = ();

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        match self.0.poll().expect("unexpected dbus IPC cancellation") {
            Async::Ready(res) => {
                let res: Message = res;

                let res = res.get1::<T>();

                match res {
                    Some(r) => Ok(Async::Ready(r)),
                    None => {
                        println!("failed to get process the response from the method call");
                        Err(())
                    }
                }
            }
            Async::NotReady => Ok(Async::NotReady)
        }
    }
}

impl mio::Evented for Watch {
    fn register(&self,
                poll: &mio::Poll,
                token: mio::Token,
                interest: mio::Ready,
                opts: mio::PollOpt) -> io::Result<()>
    {
        EventedFd(&self.fd()).register(poll, token, interest, opts)
    }

    fn reregister(&self,
                  poll: &mio::Poll,
                  token: mio::Token,
                  interest: mio::Ready,
                  opts: mio::PollOpt) -> io::Result<()>
    {
        EventedFd(&self.fd()).register(poll, token, interest, opts)
    }

    fn deregister(&self, poll: &mio::Poll) -> io::Result<()> {
        EventedFd(&self.fd()).deregister(poll)
    }
}

/*
FIXME hacking on tokio/dbus server

use super::tree::objectpath::ObjectPath;
use super::DataType;

pub trait TokioFactoryExt {
    fn method<H, T>(&self, t: T, data: D::AsyncMethod, handler: H) -> AsyncMethod<AMTFn<D>, D>
        where H: 'static + Fn(&AsyncMethodInfo<AMTFn<D>, D>) -> AsyncMethodResult, T: Into<Member<'static>>;
}

pub struct AsyncMethod<M: MethodType<D>, D: DataType> {
    cb: DebugMethod<M, D>,
    data: D::AsyncMethod,
    name: Member<'static>,
    i_args: Vec<Argument>,
    o_args: Vec<Argument>,
    anns: Annotations,
}

struct AsyncMethodFn;
*/
